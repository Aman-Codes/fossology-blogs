(self.webpackChunkfossology_blogs=self.webpackChunkfossology_blogs||[]).push([[3427],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return p},kt:function(){return f}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),f=r,g=d["".concat(l,".").concat(f)]||d[f]||u[f]||o;return n?a.createElement(g,i(i({ref:t},p),{},{components:n})):a.createElement(g,i({ref:t},p))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3997:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return i},metadata:function(){return s},toc:function(){return l},default:function(){return p}});var a=n(2122),r=n(9756),o=(n(7294),n(3905)),i={},s={unversionedId:"docs/DbManager-c",id:"docs/DbManager-c",isDocsHomePage:!1,title:"DbManager-c",description:"It is an opaque struct fo_dbManager which facilitates queries for c.",source:"@site/docs/docs/DbManager-c.md",sourceDirName:"docs",slug:"/docs/DbManager-c",permalink:"/fossology-blogs/docs/docs/DbManager-c",editUrl:"https://github.com/Aman-Codes/fossology-blogs/edit/master/docs/docs/DbManager-c.md",version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Database",permalink:"/fossology-blogs/docs/docs/Database"},next:{title:"DbManager",permalink:"/fossology-blogs/docs/docs/DbManager"}},l=[{value:"execution of simple queries",id:"execution-of-simple-queries",children:[]},{value:"separation query preparation from execution",id:"separation-query-preparation-from-execution",children:[]}],c={toc:l};function p(e){var t=e.components,n=(0,r.Z)(e,["components"]);return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"It is an opaque struct fo_dbManager which facilitates queries for c."),(0,o.kt)("p",null,'To use it you need to include "libfossdbmanager.h", within in you can find the doxygen documentation for the interface. This is a short summary of the main features.'),(0,o.kt)("p",null,"fo_dbManager* has the expected sematic for a C-style object:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},'constructors are of the form "fo_dbManager* fo_dbManager_new(',"[... parameters]",')"'),(0,o.kt)("li",{parentName:"ul"},'getters are of the form "(type) fo_dbManager_getProperty(fo_dbManager* dbManager);"'),(0,o.kt)("li",{parentName:"ul"},'setters are of the form "void fo_dbManager_setProperty(fo_dbManager* dbManager, (type) value);"'),(0,o.kt)("li",{parentName:"ul"},'destructors are "void fo',(0,o.kt)("em",{parentName:"li"},"dbManager"),"[","...","]",'(fo_dbManager* dbManager)"')),(0,o.kt)("p",null,"Of particular interest are"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"the ",(0,o.kt)("strong",{parentName:"li"},"_setLogFile()")," setter:\nopens by name a log file and redirects all output (if never set or set as NULL logs go to stdout)."),(0,o.kt)("li",{parentName:"ul"},"the ",(0,o.kt)("strong",{parentName:"li"},"_finish()")," destuctor:\nit closes the connection with the database before destroying the dbManager."),(0,o.kt)("li",{parentName:"ul"},"the ",(0,o.kt)("strong",{parentName:"li"},"_fork()")," method:\navailable if you have already a dbManager with a configuration file attached (for example created from fo_scheduler_connect_dbMan()).\nIt creates a new dbManager from the existing one, with a newly opened connection (an eventual log file is not duplicated by default).\nUseful when working with multi-threading to provide an independent connection for each child thread.")),(0,o.kt)("h2",{id:"execution-of-simple-queries"},"execution of simple queries"),(0,o.kt)("p",null,"Always remember to escape strings that you use as parameters with fo_dbManager_StringEscape()."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'char* aString = fo_dbManager_StringEscape(dbManager, "aString");\nlong aLong = 1;\nresult = fo_dbManager_Exec_printf(dbManager, "SELECT * FROM t WHERE c=\'%s\' OR c2=%ld", aString, aLong);\n')),(0,o.kt)("h2",{id:"separation-query-preparation-from-execution"},"separation query preparation from execution"),(0,o.kt)("p",null,"The dbManager allows to easily use prepared statement in a very compact way and without having to worry about memory management or string manipulations.\nFor example to prepare a select statement named name you just need one call to fo_dbManager_PrepareStatement():"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'fo_dbManager_PreparedStatement* stmt;\nstmt = fo_dbManager_PrepareStatement(dbManager, "name", "SELECT * FROM t WHERE c=$1 OR c2=$2", int, char*);\n')),(0,o.kt)("p",null,"You will get an opaque pointer back.\nTo execute the statement you just need to give this pointer to fo_dbManager_ExecPrepared together with the parameters. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'PGresult* result = fo_dbManager_ExecPrepared(stmt, 1, "s");\n')),(0,o.kt)("p",null,"You must never free the pointer: it is managed by the dbManager instance and it will be properly handled when you call fo_dbManager_free() or fo_dbManager_finish().\nYou can reuse the pointer as many times as you wish, for example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'PGresult* result1 = fo_dbManager_ExecPrepared(stmt, 1, "s");\nPGresult* result2 = fo_dbManager_ExecPrepared(stmt, 2, "t");\n')),(0,o.kt)("p",null,"You don't have to worry about keeping this pointer, since trying to prepare again the same query will give back immediately the same pointer.\nBe careful not to use the same name twice for different queries, the name here is the key."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'stmt0 = fo_dbManager_PrepareStatement(dbManager, "name", "SELECT * FROM t WHERE c=$1 OR c2=$2", int, char*);\nstmt1 = fo_dbManager_PrepareStatement(dbManager, "name", "");\nstmt2 = fo_dbManager_PrepareStatement(dbManager, "name", "SELECT * FROM t WHERE other_field=$1", int);\n/* these three pointers are the same. Trying to call _ExecPrepared(stmt2, 1) can only lead to pain.  \nIf you cannot think of a descriptive and unique name the makros __FILE__ __LINE__ or (since C99, edition2) __func__ come in handy\n*/\n')),(0,o.kt)("p",null,"This allows easily hiding calls without incurring a performance hit."),(0,o.kt)("p",null,"In the following example workingFunction() and workingFunction2() are equivalent.\nDepending on the situation you can easily choose the approach which give greater readability and separation of concerns."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'void workingFunction(fo_dbManager* dbManager) {\n  fo_dbManager_PreparedStatement* write2 = \n     fo_dbManager_PrepareStatement(dbManager, "write2", "INSERT INTO t(s) VALUES($1)", int);\n\n  for (int i=0; i<1000; i++) {\n    int j = 42 * i;\n    fo_dbManager_ExecPrepared(write2, j);\n  }\n}\n\nvoid writerFunction(fo_dbManager* dbManager, int j) {\n  fo_dbManager_ExecPrepared(\n    fo_dbManager_PrepareStatement(dbManager, "write", "INSERT INTO t(s) VALUES($1)", int), j);\n}\n\nvoid workingFunction2(fo_dbManager* dbManager) {\n  for (int i=0; i<1000; i++) {\n    int j = 42 * i;\n    writerFunction(dbManager, j);\n  }\n}\n')),(0,o.kt)("p",null,"At the time of this writing supported types are: int, long, char*, unsigned, unsigned int, unsigned long, size_t"),(0,o.kt)("p",null,"Note that, as usual with prepared statements, strings (char","*",") must ",(0,o.kt)("strong",{parentName:"p"},"not")," be escaped.\nThere is currently no support for binary data (char* will be assumed to be null terminated)."),(0,o.kt)("p",null,"Note that automatic promotion applies to any argument passed to ExecPrepared().\nFor example the ",(0,o.kt)("strong",{parentName:"p"},"only")," correct way use a short as a parameter is to use int as type specifier on the call to PrepareStatement()"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'short a;\n\nfo_dbManager_ExecPrepared(fo_dbManager_PrepareStatement(dbManager, "write", "INSERT INTO t(s) VALUES($1)", int), a);\n')),(0,o.kt)("p",null,"NB2: as you can see fo_dbManager_PrepareStatement() takes a list of types, so it can not be a function.\nIt is a macro which makes use of the ",(0,o.kt)("strong",{parentName:"p"},"VA_ARGS")," and stringification, so you should compile your agent at least with C99 to use it."))}p.isMDXComponent=!0}}]);