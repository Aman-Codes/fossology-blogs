(self.webpackChunkfossology_blogs=self.webpackChunkfossology_blogs||[]).push([[8335],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return u},kt:function(){return g}});var a=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var r=a.createContext({}),h=function(e){var t=a.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=h(e.components);return a.createElement(r.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,o=e.originalType,r=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=h(n),g=s,p=c["".concat(r,".").concat(g)]||c[g]||d[g]||o;return n?a.createElement(p,i(i({ref:t},u),{},{components:n})):a.createElement(p,i({ref:t},u))}));function g(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var o=n.length,i=new Array(o);i[0]=c;var l={};for(var r in t)hasOwnProperty.call(t,r)&&(l[r]=t[r]);l.originalType=e,l.mdxType="string"==typeof e?e:s,i[1]=l;for(var h=2;h<o;h++)i[h]=n[h];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},4828:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return i},metadata:function(){return l},toc:function(){return r},default:function(){return u}});var a=n(2122),s=n(9756),o=(n(7294),n(3905)),i={},l={unversionedId:"docs/Writing-a-FOSSology-agent-(new-work-in-progress)",id:"docs/Writing-a-FOSSology-agent-(new-work-in-progress)",isDocsHomePage:!1,title:"Writing-a-FOSSology-agent-(new-work-in-progress)",description:"An agent is a background process that is initiated by the scheduler at the request of a user. The request could come through the fossology user interface, or a fossology command line utility.",source:"@site/docs/docs/Writing-a-FOSSology-agent-(new-work-in-progress).md",sourceDirName:"docs",slug:"/docs/Writing-a-FOSSology-agent-(new-work-in-progress)",permalink:"/fossology-blogs/docs/docs/Writing-a-FOSSology-agent-(new-work-in-progress)",editUrl:"https://github.com/Aman-Codes/fossology-blogs/edit/master/docs/docs/Writing-a-FOSSology-agent-(new-work-in-progress).md",version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Writing-Agents-&-Plugins",permalink:"/fossology-blogs/docs/docs/Writing-Agents-&-Plugins"},next:{title:"fossology-gold-the-master-database-schema",permalink:"/fossology-blogs/docs/docs/fossology-gold-the-master-database-schema"}},r=[{value:"4 Steps",id:"4-steps",children:[]},{value:"Some Agent Basics",id:"some-agent-basics",children:[{value:"Idempotent",id:"idempotent",children:[]},{value:"Multiple Hosts",id:"multiple-hosts",children:[]},{value:"What to process",id:"what-to-process",children:[]},{value:"Death and Axes",id:"death-and-axes",children:[]},{value:"Checklists",id:"checklists",children:[]},{value:"Initializing",id:"initializing",children:[]},{value:"Communicating with the FOSSology Scheduler",id:"communicating-with-the-fossology-scheduler",children:[]},{value:"Repository",id:"repository",children:[]},{value:"Removing Analysis Results",id:"removing-analysis-results",children:[]},{value:"Running Standalone",id:"running-standalone",children:[]}]},{value:"Common Utilities",id:"common-utilities",children:[]},{value:"Optimizations",id:"optimizations",children:[{value:"Local repository",id:"local-repository",children:[]},{value:"Avoid reinitialization",id:"avoid-reinitialization",children:[]}]},{value:"Database",id:"database",children:[{value:"Agent table",id:"agent-table",children:[]},{value:"Agent specific tables",id:"agent-specific-tables",children:[]},{value:"Shared agent tables",id:"shared-agent-tables",children:[]},{value:"Temp tables",id:"temp-tables",children:[]}]},{value:"Agent Template",id:"agent-template",children:[{value:"Code",id:"code",children:[]}]},{value:"Agent Examples",id:"agent-examples",children:[]}],h={toc:r};function u(e){var t=e.components,n=(0,s.Z)(e,["components"]);return(0,o.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"An agent is a background process that is initiated by the ",(0,o.kt)("a",{parentName:"p",href:"http://www.fossology.org/projects/fossology/wiki/Scheduler"},"scheduler")," at the request of a user. The request could come through the fossology user interface, or a ",(0,o.kt)("a",{parentName:"p",href:"http://www.fossology.org/projects/fossology/wiki/Using_fossology_from_the_command_line"},"fossology command line utility"),"."),(0,o.kt)("p",null,"Agents are spawned by the scheduler to process a job queue. More information on ",(0,o.kt)("a",{parentName:"p",href:"http://www.fossology.org/projects/fossology/wiki/Programming_for_the_job_queue"},"programming the job queue can be found here"),"."),(0,o.kt)("h2",{id:"4-steps"},"4 Steps"),(0,o.kt)("p",null,"Creating an agent is really a four step process."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Write the agent in fossology/agents/{NewAgentName}")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Write a user interface plugin to allow the user to scheduler jobs for this new agent")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Modify fossology/scheduler/mkschedconf.c to include the new agent in the scheduler selftest.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Update the fossology package confs to include any new agent dependencies."))),(0,o.kt)("h2",{id:"some-agent-basics"},"Some Agent Basics"),(0,o.kt)("h3",{id:"idempotent"},"Idempotent"),(0,o.kt)("p",null,"idempotent |\u02c8\u012bdem\u02ccp\u014dt\u0259nt| This means that multiple requests to an agent to operate on the same data, will result in exactly the same results. So you can invoke the agent on file A as many times as you like, but the results will be the same as if you invoked the agent on file A a single time. No more data is produced, no less data is produced, and the data is the same."),(0,o.kt)("p",null,"With this property, you can re-invoke an agent without fear of corrupting the results stored in the database. This property is also used as an optimization. An agent can see that it has already processed a file, and therefore, ignore the request if asked to process it again."),(0,o.kt)("p",null,"If you want an agent to reanalyze a file you need a new agent key. ",(0,o.kt)("em",{parentName:"p"},"(add more on that and agent keys)")," You need to save the agent_pk with the result of each analysis so the result record has a unique identifier that specified what agent wrote the data. This also provides an audit trail, if you reanalyze some data, the results of the previous analysis are available for comparison."),(0,o.kt)("h3",{id:"multiple-hosts"},"Multiple Hosts"),(0,o.kt)("p",null,"Agents will be scheduled to run on one or more hosts as specified in Scheduler.conf. This means that there may be 1-to-N instances of a single agent running simultaneously on 1-to-M hosts. Fortunately, each instance doesn't need to process all files. The scheduler is your friend. The scheduler can feed each running agent unique files to process. It can even feed them files that are local to the agent. When a job is queued, and jobqueue.runonpfile is NULL, jobqueue.jq",(0,o.kt)("em",{parentName:"p"},"args are passed to the agent. If runonpfile is not null, jq_args contains sql which is executed by the scheduler, and each record of the result is passed to an agent. In this case, runonpfile contains the name of the column that the scheduler uses to determine which host to send which result to. This is how the scheduler knows what data to send to which host such that the files the agent processes are local to that host. See","[programming_for_the_job_queue ]","(",(0,o.kt)("a",{parentName:"em",href:"http://www.fossology.org/projects/fossology/wiki/Programming_for_the_job_queue"},"http://www.fossology.org/projects/fossology/wiki/Programming_for_the_job_queue")),")."),(0,o.kt)("h3",{id:"what-to-process"},"What to process"),(0,o.kt)("p",null,'So how does the agent know what to process? For example, let\'s say the agent needs to analyze all the files that were unpacked from upload "mypkg". You could write the agent with "mypkg" hardcoded as the upload to analyze, but that would be crazy. You could write it so that you pass in (cmd line arg or stdin) "mypkg". But that\'s not such a great technique given that there could be multiple instances of your agent running simultaneously on multiple machines. A good technique is to pass a data pair: pfile_pk, and file name. By doing this, the scheduler can farm out unique files to each agent instance. The scheduler can even farm out this data such that each agent only processes local files (as opposed to NFS mounted files).'),(0,o.kt)("h3",{id:"death-and-axes"},"Death and Axes"),(0,o.kt)("p",null,'Agents exist at the discretion of the scheduler. The scheduler can start them when needed and terminate them by closing the communication I/O channel (aka agent stdin). The scheduler may also send SIGKILL to an agent to make sure it really dies. When the scheduler starts a killing rampage, it SIGKILL\'s every instance of the agent. The scheduler KILL\'s an agent if the agent fails to start within 60 seconds. This means that the agent is spawned and has 60 seconds to write "OK" to stdout. That is the message telling the scheduler that the agent is ready. If no "OK" within 60 secs, then it\'s tough love from the scheduler and SIGKILL to the agent.',(0,o.kt)("em",{parentName:"p"},"(more on this later)")),(0,o.kt)("p",null,'Another time agents get SIGKILL\'d is when the scheduler simply wants to test an agent (scheduler options -t and -T). The scheduler starts the agent, checks that it started successfully (gets the "OK"), then politely sends it a SIGKILL to immediately and unceremoniously die. This sounds like the scheduler really needs to work on its communication skills, but agents need to know how to handle this kind of rejection without making it personal. That is, they need to handle a KILL without getting in some bad state that changes its future behavior - remember Idempotent.'),(0,o.kt)("h3",{id:"checklists"},"Checklists"),(0,o.kt)("h4",{id:"minimum-agent-checklist"},(0,o.kt)("strong",{parentName:"h4"},"Minimum Agent Checklist ")),(0,o.kt)("h4",{id:"each-agent-must-do-the-following"},(0,o.kt)("strong",{parentName:"h4"},"Each agent must do the following:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Start heartbeat")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},'Tell scheduler agent is ready (write "OK" to stdout)')),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Loop to read stdin (stop when stdin is closed)"))),(0,o.kt)("h4",{id:"typical-agent-checklist"},(0,o.kt)("strong",{parentName:"h4"},"Typical Agent Checklist")),(0,o.kt)("p",null,"Agents typically do the following:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Initialize internal data structures")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Open the fossology database")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Get their unique agent key")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Process command line options")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Start heartbeat")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},'Tell scheduler agent is ready (write "OK" to stdout)')),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Loop to read stdin (stop when stdin is closed) ** Do work, based on data from stdin")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Close the database")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"exit"))),(0,o.kt)("h3",{id:"initializing"},"Initializing"),(0,o.kt)("h4",{id:"init-data-structs"},(0,o.kt)("strong",{parentName:"h4"},"Init Data structs")),(0,o.kt)("h4",{id:"finding-agent-key"},(0,o.kt)("strong",{parentName:"h4"},"Finding Agent Key")),(0,o.kt)("h4",{id:"flags-and-options"},(0,o.kt)("strong",{parentName:"h4"},"Flags and Options")),(0,o.kt)("h4",{id:"db-access"},(0,o.kt)("strong",{parentName:"h4"},"DB access")),(0,o.kt)("h3",{id:"communicating-with-the-fossology-scheduler"},"Communicating with the FOSSology Scheduler"),(0,o.kt)("p",null,"Agents communicate to the scheduler via stdin/stdout. This simple interface makes it easy for an agent to be written in any language. Agents must also support a heartbeat ",(0,o.kt)("em",{parentName:"p"}," (link to below).")," However, the current agent library of common functions is only written in C. Some common agent utilities are also available as standalone utilities. ",(0,o.kt)("em",{parentName:"p"}," (link to rep utilities)")),(0,o.kt)("h4",{id:"agent-parameters"},(0,o.kt)("strong",{parentName:"h4"},"Agent parameters")),(0,o.kt)("p",null,"Important fields to queue an agent are jq_args and jq_runonpfile. These contain the agent specific code. jq_args contains a string that is passed to the agent UNLESS jq_runonpfile is set. In the latter case, jq_args is sql that the scheduler runs, and then the scheduler passes the results (one row at a time) to the agent. jq_runonpfile is the name of a column returned by the query and it is used to determine which host receives the data. So jq_runonpfile needs to be the name of the column that returns the sha1 of the pfile."),(0,o.kt)("p",null,'As soon as the agent writes "OK", the scheduler sees that you are ready to accept data. If the scheduler is ready to run the agent, it makes sure it has data (runs the sql from jq_args), then it starts passing, one line at a time, the sql results to the agent, using the jq_runonpfile to determine which host should get the data.'),(0,o.kt)("p",null,'The code in jq_args should logically say "given an upload_pk, find all the pfiles, that this agent_pk has not yet processed". Typically, the query also has a limit clause so that a single query won\'t hog the scheduler. Limit 5000 is what we use for bsam-engine. So after every 5000 records passed to bsam_engine, the scheduler looks to see if other higher priority jobs need to run. If not, is runs the exact same query (jq_args) again. This is why the logic says "that this agent_pk has not yet processed".'),(0,o.kt)("h4",{id:"messages"},(0,o.kt)("strong",{parentName:"h4"},"Messages")),(0,o.kt)("p",null,"An agent can send the following commands to the scheduler (by writing to stdout):"),(0,o.kt)("table",null,(0,o.kt)("tr",null,(0,o.kt)("td",null,"Command"),(0,o.kt)("td",null,"Meaning")),(0,o.kt)("tr",null,(0,o.kt)("td",null,"OK"),(0,o.kt)("td",null,"This tells the scheduler that the agent is ready to accept data (eg file to process)")),(0,o.kt)("tr",null,(0,o.kt)("td",null,"FATAL message"),(0,o.kt)("td",null,"This tells the scheduler to write a FATAL error (the message) to the scheduler log file.")),(0,o.kt)("tr",null,(0,o.kt)("td",null,"FATAL: message"),(0,o.kt)("td",null,"Same as FATAL")),(0,o.kt)("tr",null,(0,o.kt)("td",null,"ERROR message"),(0,o.kt)("td",null,"Write Error message to log file")),(0,o.kt)("tr",null,(0,o.kt)("td",null,"ERROR: message"),(0,o.kt)("td",null,"Same as ERROR")),(0,o.kt)("tr",null,(0,o.kt)("td",null,"WARNING message"),(0,o.kt)("td",null,"Write Warning message to log file")),(0,o.kt)("tr",null,(0,o.kt)("td",null,"WARNING: message"),(0,o.kt)("td",null,"Same as WARNING")),(0,o.kt)("tr",null,(0,o.kt)("td",null,"LOG message"),(0,o.kt)("td",null,"Write message to log file")),(0,o.kt)("tr",null,(0,o.kt)("td",null,"Success"),(0,o.kt)("td",null,"Not currently used")),(0,o.kt)("tr",null,(0,o.kt)("td",null,"Heartbeat"),(0,o.kt)("td",null,"The scheduler must receive a heartbeat every MAXHEARTBEAT seconds or else it will assume the agent has died or is hung. If the agent times out, the scheduler log the event and then attempt to kill it. MAXHEARTBEAT is a constant in agents.h, default is 180 seconds.")),(0,o.kt)("tr",null,(0,o.kt)("td",null,"DB: sql"),(0,o.kt)("td",null,"The scheduler executes sql.")),(0,o.kt)("tr",null,(0,o.kt)("td",null,"ItemsProcessed integer"),(0,o.kt)("td",null,"Scheduler updates items processed for the job")),(0,o.kt)("tr",null,(0,o.kt)("td",null,"ECHO message"),(0,o.kt)("td",null,"same as LOG")),(0,o.kt)("tr",null,(0,o.kt)("td",null,"JQ_SUBS string value(proposed for future)"),(0,o.kt)("td",null,'Tells the scheduler to substitute value for string in jq_args. For example, JQ_SUBS $agent_pk 1234 tells the scheduler to look at jq_args and replace every "$agent_pk" string with "1234". This command may be sent multiple times to substitute multiple different variables (up to MAXJQSUBS set to 10 in spawn.h).')),(0,o.kt)("tr",null,(0,o.kt)("td",null),(0,o.kt)("td",null,"Writing anything else to the scheduler, is treated like LOG"))),(0,o.kt)("h3",{id:"repository"},"Repository"),(0,o.kt)("h3",{id:"removing-analysis-results"},"Removing Analysis Results"),(0,o.kt)("h3",{id:"running-standalone"},"Running Standalone"),(0,o.kt)("h2",{id:"common-utilities"},"Common Utilities"),(0,o.kt)("h2",{id:"optimizations"},"Optimizations"),(0,o.kt)("h3",{id:"local-repository"},"Local repository"),(0,o.kt)("h3",{id:"avoid-reinitialization"},"Avoid reinitialization"),(0,o.kt)("h2",{id:"database"},"Database"),(0,o.kt)("h3",{id:"agent-table"},"Agent table"),(0,o.kt)("h3",{id:"agent-specific-tables"},"Agent specific tables"),(0,o.kt)("h3",{id:"shared-agent-tables"},"Shared agent tables"),(0,o.kt)("h3",{id:"temp-tables"},"Temp tables"),(0,o.kt)("h2",{id:"agent-template"},"Agent Template"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"http://www.fossology.org/projects/fossology/wiki/Agent_template_"},"Agent Template")),(0,o.kt)("h3",{id:"code"},"Code"),(0,o.kt)("h2",{id:"agent-examples"},"Agent Examples"))}u.isMDXComponent=!0}}]);