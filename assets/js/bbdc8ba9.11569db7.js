(self.webpackChunkfossology_blogs=self.webpackChunkfossology_blogs||[]).push([[4870],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return h},kt:function(){return u}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},h=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},f=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),f=c(n),u=i,p=f["".concat(l,".").concat(u)]||f[u]||d[u]||o;return n?a.createElement(p,r(r({ref:t},h),{},{components:n})):a.createElement(p,r({ref:t},h))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=f;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},6160:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return r},metadata:function(){return s},toc:function(){return l},default:function(){return h}});var a=n(2122),i=n(9756),o=(n(7294),n(3905)),r={},s={unversionedId:"docs/Monk",id:"docs/Monk",isDocsHomePage:!1,title:"Monk",description:"The monk license scanner is a full text license scanner searching for any license text contained in the license-ref table.",source:"@site/docs/docs/Monk.md",sourceDirName:"docs",slug:"/docs/Monk",permalink:"/fossology-blogs/docs/docs/Monk",editUrl:"https://github.com/Aman-Codes/fossology-blogs/edit/master/docs/docs/Monk.md",version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Mimetype-Agent",permalink:"/fossology-blogs/docs/docs/Mimetype-Agent"},next:{title:"The Monk bulk scan is a way to conclude licenses based on text snippets contained in a file",permalink:"/fossology-blogs/docs/docs/MonkBulk"}},l=[{value:"Scheduler Mode",id:"scheduler-mode",children:[]},{value:"CLI Mode",id:"cli-mode",children:[{value:"What is a match for monk?",id:"what-is-a-match-for-monk",children:[]},{value:"Full",id:"full",children:[]},{value:"Diff",id:"diff",children:[]},{value:"Text Overlap",id:"text-overlap",children:[]}]},{value:"Monk Workflow",id:"monk-workflow",children:[]}],c={toc:l};function h(e){var t=e.components,n=(0,i.Z)(e,["components"]);return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"The monk license scanner is a full text license scanner searching for any license text contained in the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/fossology/fossology/wiki/License-Ref-Table"},"license-ref table"),"."),(0,o.kt)("p",null,"In addition to the detected license it produces a full diff output to see differences of the texts if the match is not 100%."),(0,o.kt)("p",null,"monk is a full text license scanner."),(0,o.kt)("p",null,"Its purpose is to look for occurrences of reference license texts in the given files."),(0,o.kt)("h2",{id:"scheduler-mode"},"Scheduler Mode"),(0,o.kt)("p",null,"When started by the Fossology scheduler, monk tries to match files in the Fossology repo."),(0,o.kt)("p",null,"The result is written in the database and can be accessed from the Fossology web interface."),(0,o.kt)("h2",{id:"cli-mode"},"CLI Mode"),(0,o.kt)("p",null,"When run in command line mode it expects filenames as arguments and tries to match them against all the licenses, it then prints a line for each found file/license pair."),(0,o.kt)("p",null,"Note that this mode still requires a connection to the regular fossology database, as it needs to retrieve all the license reference texts."),(0,o.kt)("p",null,"To change the path of the database configuration file use the -c option to point to your local Fossology installation (by default in /usr/local/etc/fossology/ or as configured at compilation)."),(0,o.kt)("p",null,"At the time of this writing monk supports the following options:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Usage: /usr/local/share/fossology/monk/agent/monk [options] -- [file [file [...]]\n  -h   :: help (print this message), then exit.\n  -c   :: specify the directory for the system configuration.\n  -v   :: verbose output.\n  file :: if a file print the licenses detected.\n  -V   :: print the version info, then exit.\n")),(0,o.kt)("p",null,"If you use the -v option you will also get output for files which do not match"),(0,o.kt)("p",null,"Tip: if you want to recursively scan a folder use find, for example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"find /directory/to/scan/ -type f -exec /path/to/fossology/monk/agent/monk '{}' +\n")),(0,o.kt)("h3",{id:"what-is-a-match-for-monk"},"What is a match for monk?"),(0,o.kt)("p",null,"When monk scans a file it compares it with all the reference text contained in the fossology database."),(0,o.kt)("p",null,"The comparison is done word-by-word, ignoring all white space between each word."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'"this is a sentence" = "this  is a <tab>  sentence" \n')),(0,o.kt)("p",null,"N.B. Work is in progress to conform monk to the specifications of SPDX."),(0,o.kt)("p",null,"The rules that follow describe some key differences, but we intend to improve on them."),(0,o.kt)("p",null,"No case normalization is performed:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'"A Sentence With Strange Capital Letters" != "A SENTENCE WITH STRANGE CAPITAL LETTERS" \n')),(0,o.kt)("p",null,"Commas and punctuation are not discarded, but they are not words on their own."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'"no comma between these words" != "no comma, between these words" \n"a comma, between these words" != "a comma , between these words" \n')),(0,o.kt)("p",null,'There is no special handling of "(c)" or of quotes:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"\"(c) of 'Fossology'\" != \"Copyright of ''Fossology''\" \n")),(0,o.kt)("p",null,"Programming language specific comment delimiters are not considered"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'"* This is a line of a license inside a source file" != "// This is a line of a license inside a source file" \n')),(0,o.kt)("h3",{id:"full"},"Full"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'./monk ../agent_tests/testlicenses/expectedFull/Apache-*\nfound full match between "../agent_tests/testlicenses/expectedFull/Apache-1.1" and "Apache-1.1" (rf_pk=221); matched: 0+2825\nfound full match between "../agent_tests/testlicenses/expectedFull/Apache-2.0" and "Apache-2.0" (rf_pk=213); matched: 0+10272\n')),(0,o.kt)("p",null,"in case of a complete match ('full 'match') between the file and a license text, monk prints the position in the text where the match was found."),(0,o.kt)("p",null,"The format is 'matched: startPosition+length' the unit of measure is 1-byte characters"),(0,o.kt)("h3",{id:"diff"},"Diff"),(0,o.kt)("p",null,"If some words are changed monk still finds a match, but it advertises it as a 'diff match' with a percentual which depends on the extent of the changes."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'./monk ../agent_tests/testlicenses/expectedDiff/GPL-1.0,biggerremove ../agent_tests/testlicenses/expectedDiff/GPL-1.0,biggeraddition \nfound diff match between "../agent_tests/testlicenses/expectedDiff/GPL-1.0,biggeraddition" and "GPL-1.0" (rf_pk=384); rank 95; diffs: {t[20+6025] M0 s[20+6143], t[6047+709] M+ s[6167], t[6759+6583] M0 s[6167+6712]}\nfound diff match between "../agent_tests/testlicenses/expectedDiff/GPL-1.0,biggerremove" and "GPL-1.0" (rf_pk=384); rank 98; diffs: {t[20+2489] M0 s[20+2540], t[2511] M- s[2566+201], t[2511+9917] M0 s[2769+10110]}\n')),(0,o.kt)("p",null,"In this case monk prints an array describing the differences between the file and the license."),(0,o.kt)("p",null,"The format is 'diff: {diff1, ..., diffN}' and each difference is encoded as follows:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"the numbers in the square brackets encode the position: startPosition+length (1-byte characters)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"if the length is not relevant only the position is encoded as ","[startPosition]")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"t stands for 'text' (the input file), s stands for 'searched' (the reference license which matched)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"the type of difference is encoded by")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"M0: text that is equal to the reference text\nM-: text that is in the reference but not in the file (removed text)\nM+: text that is not in the reference but is in the file (added text)\nMR: text replaced"))),(0,o.kt)("p",null,"So in the example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"'t[2511+9917] M0 s[2769+10110]' means\n  t[2511+9917]   =  in the file the 9917 characters after character 2511\n  M0             =  are equals to\n  s[2769+10110]  =  the 10110 characters after character 2769 in the reference license\n")),(0,o.kt)("p",null,"Note that whitespace is counted, but is ignored in the comparison. So this means that the reference license here has 193 whitespace characters more than the text."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"'t[2511] M- s[2566+201]' means\n   t[2511]       =  in the file at position 2511\n   M-            =  from file are missing\n   s[2566+201]   =  the 201 characters after character 2566 in the reference license\n\n't[6047+709] M+ s[6167]' means\n  t[6047+709]    =  in the file the 709 characters after character 6079\n  M+             =  are added\n  s[6167]        =  at position 6167 in the reference license\n")),(0,o.kt)("h3",{id:"text-overlap"},"Text Overlap"),(0,o.kt)("p",null,"Since April there is a filtering of overlapping text match results"),(0,o.kt)("p",null,"monk/agent/match.c:73 finds all matches in the database"),(0,o.kt)("p",null,"monk/agent/match.c:57 filtering and dropping of sub matches"),(0,o.kt)("p",null,"monk/agent/match.c:291 find a super match by comparing two of these"),(0,o.kt)("p",null,"Example (every single character is a token):"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Text = abcdefghij"),(0,o.kt)("li",{parentName:"ul"},"License A = abcdxfyhij"),(0,o.kt)("li",{parentName:"ul"},"License B = cdxf"),(0,o.kt)("li",{parentName:"ul"},"Match MA = abcdefghij"),(0,o.kt)("li",{parentName:"ul"},"Match MB = cdef")),(0,o.kt)("p",null,"So the Match MA contains Match MB, but MA is <100%.\nThe licenses do not fulfil  monk/agent/match.c:280 licensesCanNotOverlap-Condition, because License A contains the License B."),(0,o.kt)("p",null,"So, for this example, the ranking is not considered:\nrankMA= 8/12 > 3/5 = rankMB ",(0,o.kt)("em",{parentName:"p"},"not")," considered."),(0,o.kt)("p",null,"Therefore a match smaller can still exists (although it might be superfluous)."),(0,o.kt)("p",null,"Note another example on the ranking. "),(0,o.kt)("p",null,"Another example, but without tokens e and x would result in:"),(0,o.kt)("p",null,"rankMA'=8/10<3/3=rankMB'. "),(0,o.kt)("p",null,"As done in the bSAM ranking, the Jaccard could have a convex function where the result is multiplied with the length of the mathcing area - so longer matches get more weight than shorter matches.  For example:"),(0,o.kt)("p",null,"rankMA\xb0 = 9 ",(0,o.kt)("em",{parentName:"p"}," (8/10)^t > 3 ")," (3/3)^t = rankMB\xb0 for t=4."),(0,o.kt)("p",null,"These changes are under construction and might change w.r.t parameterization."),(0,o.kt)("h2",{id:"monk-workflow"},"Monk Workflow"),(0,o.kt)("p",null,"These is a summary of the steps followed by monk when looking for licenses."),(0,o.kt)("h4",{id:"database-connection"},"Database connection"),(0,o.kt)("p",null,"Monk establishes a database connection through fo_scheduler_connect_dbMan(), this (as usual for other agents) also handles the initiation of the scheduler interface protocol if appropriate (--scheduler_start cli option)."),(0,o.kt)("h4",{id:"license-tokenizing"},"License tokenizing"),(0,o.kt)("p",null,"all the available license reference text are read from license_ref and tokenized.\nThey are then stored in an array of ","[struct_License]",".\nFrom this point on the array is read-only and reused for each scanned file."),(0,o.kt)("h4",{id:"file-scanning"},"File scanning"),(0,o.kt)("p",null,"filenames are read from the command line (CLI mode) or from the database using the uploadId provided by the scheduler.\nIn this phase monk runs with multiple threads, each taking care of a file at a time and trying to match it using the shared array of licenses."),(0,o.kt)("h4",{id:"file-contents-tokenization"},"File contents tokenization"),(0,o.kt)("p",null,"the contents of the file are tokenized to an array of tokens."),(0,o.kt)("h4",{id:"match-finding"},"Match finding"),(0,o.kt)("p",null,"each thread loops over the licenses and compares its reference text with the file tokens.\nEither all the license tokens are contiguously found inside the file ('full match') or there are some differences."),(0,o.kt)("h4",{id:"diff-finding"},"Diff finding"),(0,o.kt)("p",null,"The process starts when the first token of the license in found in a position inside the file, from there on tokens are compared.\nEvery time that monk finds a difference between the text and the reference it tries to find the next series of tokens that is again equal.\nThe two parameters monk.h:MAX_ALLOWED_DIFF_LENGTH and monk.h:MIN_TRAILING_MATCHES govern this process.\nThe former is the maximum number of tokens that can be jumped on either side (combined) before monk decides that the current match is negative and tries with the next one.\nThe latter is the minimum number of consecutive equal tokens needed to decide that the current difference finishes there, so monk can continue trying to match the following tokens."),(0,o.kt)("p",null,"If the last token of the license is found it declares the match positive and it is saved for the next stage.\nIf the end of the file is not reached a new match is tried starting from one token after the first of the current attempt."),(0,o.kt)("h4",{id:"matches-ranking"},"Matches ranking"),(0,o.kt)("p",null,"Each diff match is classified according to the Jaccard Index: rank = #{matched} / (#{added} + #{removed} + #{matched})\nFull matches have all the same rank, higher than that of any diff match."),(0,o.kt)("p",null,"Matches with a rank lower than monk.h:MIN_ALLOWED_RANK will be automatically discarded."),(0,o.kt)("h4",{id:"matches-filtering"},"Matches filtering"),(0,o.kt)("p",null,"During the previous scan phase all the positive matches were collected inside an array.\nWhen matches with all the reference license have been tried, the array is analyzed and monk decides which results are important and which match must be discarded."),(0,o.kt)("p",null,"The rule for deciding the matches to keep is:\nfor each pair of matches which are contained one in the other, only that with the bigger rank is kept."),(0,o.kt)("p",null,"This is the strategy to obtain a group of matches with this property:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"divide the matches in ordered groups in which the first element contains all the other matches in the same group."),(0,o.kt)("li",{parentName:"ul"},"for each group: if the match with the biggest rank is the first, keep only the first, otherwise discard the first and recursively analyze the current group.")),(0,o.kt)("h4",{id:"printsave-result"},"Print/save result"),(0,o.kt)("p",null,"In scheduler mode results are saved in the database. Each match is saved in license_file and the primary key is used to link this information to the information about the differences, which is saved in the highlight table.\nThe database scheme used to store this information is described in the database model documentation. // TODO cross-link"),(0,o.kt)("p",null,"In command line mode the results are printed to stdout, according to the format described in the user documentation."))}h.isMDXComponent=!0}}]);