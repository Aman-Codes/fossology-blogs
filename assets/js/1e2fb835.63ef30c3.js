(self.webpackChunkfossology_blogs=self.webpackChunkfossology_blogs||[]).push([[6029],{3905:function(e,n,t){"use strict";t.d(n,{Zo:function(){return p},kt:function(){return m}});var o=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,o,i=function(e,n){if(null==e)return{};var t,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=o.createContext({}),c=function(e){var n=o.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},p=function(e){var n=c(e.components);return o.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),d=c(t),m=i,f=d["".concat(s,".").concat(m)]||d[m]||u[m]||a;return t?o.createElement(f,l(l({ref:n},p),{},{components:t})):o.createElement(f,l({ref:n},p))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,l=new Array(a);l[0]=d;var r={};for(var s in n)hasOwnProperty.call(n,s)&&(r[s]=n[s]);r.originalType=e,r.mdxType="string"==typeof e?e:i,l[1]=r;for(var c=2;c<a;c++)l[c]=t[c];return o.createElement.apply(null,l)}return o.createElement.apply(null,t)}d.displayName="MDXCreateElement"},3009:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return l},metadata:function(){return r},toc:function(){return s},default:function(){return p}});var o=t(2122),i=t(9756),a=(t(7294),t(3905)),l={},r={unversionedId:"docs/FOSSology-scanners-in-CI",id:"docs/FOSSology-scanners-in-CI",isDocsHomePage:!1,title:"License/Copyright scanning automation using FOSSology in CI tools",description:"License and copyright scanning can be put into continuous job allowing developers to find out underlying license in the code and fix it as early as possible. This will greatly reduce the work at final clearance from OSS team and also will reduce rework need to be done in case of OSS license violation.",source:"@site/docs/docs/FOSSology-scanners-in-CI.md",sourceDirName:"docs",slug:"/docs/FOSSology-scanners-in-CI",permalink:"/fossology-blogs/docs/docs/FOSSology-scanners-in-CI",editUrl:"https://github.com/Aman-Codes/fossology-blogs/edit/master/docs/docs/FOSSology-scanners-in-CI.md",version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"FOSSology-Test-Automation",permalink:"/fossology-blogs/docs/docs/FOSSology-Test-Automation"},next:{title:"File-Comparing-and-Diff-type-plugins",permalink:"/fossology-blogs/docs/docs/File-Comparing-and-Diff-type-plugins"}},s=[{value:"Scanners in CI",id:"scanners-in-ci",children:[{value:"Scanning modes",id:"scanning-modes",children:[]}]},{value:"Whitelisting",id:"whitelisting",children:[{value:"Format",id:"format",children:[]},{value:"Explanation",id:"explanation",children:[]}]},{value:"Setting up GitLab CI",id:"setting-up-gitlab-ci",children:[{value:"The diff for the Merge Requests",id:"the-diff-for-the-merge-requests",children:[]},{value:"Repo scan",id:"repo-scan",children:[]},{value:"Sample configuration",id:"sample-configuration",children:[]}]},{value:"Setting up Travis CI",id:"setting-up-travis-ci",children:[{value:"The diff for Pull Requests",id:"the-diff-for-pull-requests",children:[]},{value:"Repo scan",id:"repo-scan-1",children:[]},{value:"Sample configuration",id:"sample-configuration-1",children:[]}]},{value:"Docker image",id:"docker-image",children:[]}],c={toc:s};function p(e){var n=e.components,t=(0,i.Z)(e,["components"]);return(0,a.kt)("wrapper",(0,o.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"License and copyright scanning can be put into continuous job allowing developers to find out underlying license in the code and fix it as early as possible. This will greatly reduce the work at final clearance from OSS team and also will reduce rework need to be done in case of OSS license violation."),(0,a.kt)("p",null,"To aid with the task, FOSSology CI scanner image can be used with the GitLab CI and Travis CI. The image can be pulled from Docker Hub using ",(0,a.kt)("inlineCode",{parentName:"p"},"fossology/fossology:scanner")),(0,a.kt)("h2",{id:"scanners-in-ci"},"Scanners in CI"),(0,a.kt)("p",null,"The current runner image ships with following scanners:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"nomos"),(0,a.kt)("li",{parentName:"ol"},"ojo"),(0,a.kt)("li",{parentName:"ol"},"copyright"),(0,a.kt)("li",{parentName:"ol"},"keyword")),(0,a.kt)("p",null,"This provides a good set of license scanning tool set. Also, with the help of copyright and keyword scanner, potential violations can be identified and resolved at the earliest."),(0,a.kt)("h3",{id:"scanning-modes"},"Scanning modes"),(0,a.kt)("p",null,"Due to various stages and operations over SDLC, various scanning modes are required. Thus, the image provides following two scanning modes:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Diff scan",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Scans only diff between two branch (merge request)."),(0,a.kt)("li",{parentName:"ul"},"Good choice to run with existing job on CI for every push."),(0,a.kt)("li",{parentName:"ul"},"Provide early detection at commit level."))),(0,a.kt)("li",{parentName:"ol"},"Repo scan",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Scans complete repo, not just the diffs."),(0,a.kt)("li",{parentName:"ul"},"Good to run at every release tag and scheduled builds."),(0,a.kt)("li",{parentName:"ul"},"Provides good overview of the repository.")))),(0,a.kt)("p",null,"The scanning modes can be easily set as a command line argument, explained bellow."),(0,a.kt)("h2",{id:"whitelisting"},"Whitelisting"),(0,a.kt)("p",null,"Since a repo can contain test sets and development dependency list which are not shipped in a release, a whitelist is setup in the scanners to ignore such file/folders."),(0,a.kt)("p",null,"Also, since the license scanners do not know which licenses are good or bad for the project, they can also be listed as whitelisted and will not be reported."),(0,a.kt)("h3",{id:"format"},"Format"),(0,a.kt)("p",null,"Sample whitelist file can be found at ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/fossology/fossology/blob/master/utils/automation/whitelist.sample.json"},(0,a.kt)("inlineCode",{parentName:"a"},"utils/automation/whitelist.sample.json")),". The whitelist file must be stored at root of repo and names ",(0,a.kt)("inlineCode",{parentName:"p"},"whitelist.json"),"."),(0,a.kt)("p",null,"The license scanners (nomos and ojo) read the whitelisted licenses from the file and every scanner reads the list of files to be ignored from the file."),(0,a.kt)("p",null,"The file is a JSON document with two arrays:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"licenses"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Licenses to be ignored from scanning."),(0,a.kt)("li",{parentName:"ul"},"Case sensitive."))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"exclude"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Files to be ignored from scanning."),(0,a.kt)("li",{parentName:"ul"},"Understands wild characters like ",(0,a.kt)("inlineCode",{parentName:"li"},"*"))))),(0,a.kt)("h3",{id:"explanation"},"Explanation"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "licenses": [\n    "GPL-2.0+",\n    "GPL-2.0",\n    "LGPL-2.1+"\n  ],\n  "exclude": [\n    "*/agent_tests/*",\n    "src/vendor/*"\n  ]\n}\n')),(0,a.kt)("p",null,"The above whitelist file will have the following effects on the scanning:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"The licenses ",(0,a.kt)("inlineCode",{parentName:"li"},"GPL-2.0+"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"GPL-2.0")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"LGPL-2.1+")," will be ignored if found during a scan. You should place your main licenses here."),(0,a.kt)("li",{parentName:"ol"},"Any file with ",(0,a.kt)("inlineCode",{parentName:"li"},"/agent_tests/")," in its path will be ignored from scanning. Example of test cases being ignored."),(0,a.kt)("li",{parentName:"ol"},"Any file under ",(0,a.kt)("inlineCode",{parentName:"li"},"src/vendor/")," folder will be ignored from scanning. Example of development artifacts.")),(0,a.kt)("h2",{id:"setting-up-gitlab-ci"},"Setting up GitLab CI"),(0,a.kt)("p",null,"The CI setup is pretty simple. However, there are some constraints which must be taken care of."),(0,a.kt)("h3",{id:"the-diff-for-the-merge-requests"},"The diff for the Merge Requests"),(0,a.kt)("p",null,"The diff are fetched by the ",(0,a.kt)("a",{parentName:"p",href:"https://docs.gitlab.com/ee/api/merge_requests.html"},"GitLab API")," which requires authentication. To set this up, you must create a ",(0,a.kt)("a",{parentName:"p",href:"https://gitlab.com/profile/personal_access_tokens"},"Personal Access Token")," with at least ",(0,a.kt)("inlineCode",{parentName:"p"},"read_api")," privilege and put it as an environment variable in CI/CD settings."),(0,a.kt)("p",null,"The name of the variable should be ",(0,a.kt)("inlineCode",{parentName:"p"},"API_TOKEN")," and the ",(0,a.kt)("inlineCode",{parentName:"p"},"Protected")," flag should not be set, otherwise the pipeline will fail for non-protected branches."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Note:")," Every fork should set the ",(0,a.kt)("inlineCode",{parentName:"p"},"API_TOKEN")," as forks can not read variables from main repo."),(0,a.kt)("h3",{id:"repo-scan"},"Repo scan"),(0,a.kt)("p",null,"Repo scan does not interact with other entities and thus do not require any other authentication methods."),(0,a.kt)("h3",{id:"sample-configuration"},"Sample configuration"),(0,a.kt)("p",null,"The sample CI file can be found at ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/fossology/fossology/blob/master/utils/automation/.gitlab-ci.sample.yml"},(0,a.kt)("inlineCode",{parentName:"a"},"utils/automation/.gitlab-ci.sample.yml")),"."),(0,a.kt)("h2",{id:"setting-up-travis-ci"},"Setting up Travis CI"),(0,a.kt)("p",null,"The Travis CI does not require additional steps to be followed for public projects."),(0,a.kt)("h3",{id:"the-diff-for-pull-requests"},"The diff for Pull Requests"),(0,a.kt)("p",null,"The diff can only be fetched from GitHub API for now. So projects not hosted on GitHub will not work."),(0,a.kt)("h3",{id:"repo-scan-1"},"Repo scan"),(0,a.kt)("p",null,"Repo scan does not interact with APIs, so can be used by any repository."),(0,a.kt)("h3",{id:"sample-configuration-1"},"Sample configuration"),(0,a.kt)("p",null,"The sample CI file can be found at ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/fossology/fossology/blob/master/utils/automation/.travis.sample.yml"},(0,a.kt)("inlineCode",{parentName:"a"},"utils/automation/.travis.sample.yml")),"."),(0,a.kt)("h2",{id:"docker-image"},"Docker image"),(0,a.kt)("p",null,"The CI jobs should use the image created by the ",(0,a.kt)("inlineCode",{parentName:"p"},"utils/automation/Dockerfile.ci")," or pulled from Docker Hub as ",(0,a.kt)("inlineCode",{parentName:"p"},"fossology/fossology:runner")," image to get the scanners."),(0,a.kt)("p",null,"The scanner (at ",(0,a.kt)("inlineCode",{parentName:"p"},"/bin/fossologyscanner"),") accept following parameters:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"nomos"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Run ",(0,a.kt)("inlineCode",{parentName:"li"},"nomos")," scanner"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"ojo"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Run ",(0,a.kt)("inlineCode",{parentName:"li"},"ojo")," scanner"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"copyright"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Run ",(0,a.kt)("inlineCode",{parentName:"li"},"copyright")," scanner"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"keyword"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Run ",(0,a.kt)("inlineCode",{parentName:"li"},"keyword")," scanner"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"repo"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Run on whole repo (if not provided, the diff scan is done)")))),(0,a.kt)("p",null,"All the parameters can be used in any combination to get the desired functionality."),(0,a.kt)("h4",{id:"merge-commit-scans"},"Merge commit scans"),(0,a.kt)("p",null,"To scan commits at creation of every merge request, you can all following step to your pipeline:"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"GitLab")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"stages:\n  - license\n\nlicense_check:\n  stage: license\n  image: fossology/fossology:runner\n  script:\n    - /bin/fossologyscanner nomos ojo\n  only: [merge_requests]\n  artifacts:\n    paths:\n    - results\n    expire_in: 1 week\n    when: on_failure\n\ncopyright_check:\n  stage: license\n  image: fossology/fossology:runner\n  script:\n    - /bin/fossologyscanner copyright keyword\n  only: [merge_requests]\n  artifacts:\n    paths:\n    - results\n    expire_in: 1 week\n    when: on_failure\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Travis")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'    - stage: Compliance\n      name: copyright_check\n      services: docker\n      script:\n        - >-\n          if [ "$TRAVIS_PULL_REQUEST" != "false" ]; then\n          docker pull fossology/fossology:scanner\n          && docker run --name "fossologyscanner" -w "/opt/repo" -v ${PWD}:/opt/repo\n          -e TRAVIS=${TRAVIS} -e TRAVIS_REPO_SLUG=${TRAVIS_REPO_SLUG}\n          -e TRAVIS_PULL_REQUEST=${TRAVIS_PULL_REQUEST}\n          fossology/fossology:scanner "/bin/fossologyscanner" copyright keyword ;\n          fi\n    - stage: Compliance\n      name: license_check\n      services: docker\n      script:\n        - >-\n          if [ "$TRAVIS_PULL_REQUEST" != "false" ]; then\n          docker pull fossology/fossology:scanner\n          && docker run --name "fossologyscanner" -w "/opt/repo" -v ${PWD}:/opt/repo\n          -e TRAVIS=${TRAVIS} -e TRAVIS_REPO_SLUG=${TRAVIS_REPO_SLUG}\n          -e TRAVIS_PULL_REQUEST=${TRAVIS_PULL_REQUEST}\n          fossology/fossology:scanner "/bin/fossologyscanner" nomos ojo ;\n          fi\n')),(0,a.kt)("p",null,"It will create a new stage in your pipeline with two jobs namely ",(0,a.kt)("inlineCode",{parentName:"p"},"license_check")," to scan for licenses using ",(0,a.kt)("inlineCode",{parentName:"p"},"nomos")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"ojo")," scanner and ",(0,a.kt)("inlineCode",{parentName:"p"},"copyright_check")," to scan with ",(0,a.kt)("inlineCode",{parentName:"p"},"copyright")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"keyword")," scanner. Make sure you have the ",(0,a.kt)("inlineCode",{parentName:"p"},"only: [merge_requests]")," in place otherwise the diff could not be recreated in GitLab."),(0,a.kt)("p",null,"For Travis, the scan artifacts will be created under ",(0,a.kt)("strong",{parentName:"p"},"results")," folder."),(0,a.kt)("h4",{id:"repo-scan-2"},"Repo scan"),(0,a.kt)("p",null,"Repo scan can be done in a similar way by just adding ",(0,a.kt)("inlineCode",{parentName:"p"},"repo")," as another argument."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"stages:\n  - license\n\nrepo_license_scan:\n  stage: license\n  image: fossology/fossology:runner\n  script:\n    - /bin/fossologyscanner repo nomos ojo\n  only: [tags]\n\nrepo_copyright_check:\n  stage: license\n  image: fossology/fossology:runner\n  script:\n    - /bin/fossologyscanner copyright keyword repo\n  only: [tags]\n")),(0,a.kt)("p",null,"These jobs will be similar to the jobs created above with one exception. The jobs now run with ",(0,a.kt)("inlineCode",{parentName:"p"},"repo")," argument. Since, it is a nice idea to run this scan at every release, the ",(0,a.kt)("inlineCode",{parentName:"p"},"only: [tags]")," will run the jobs only at releases (tagging)."))}p.isMDXComponent=!0}}]);